[
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/getting-started/",
	"title": "Server Setup",
	"tags": [],
	"description": "",
	"content": "This section is meant to get you started using Juzu Server via a Docker image.\nInstalling the Juzu Server Image The SDK communicates with a Juzu Server instance using gRPC. Cobalt distributes a docker image that contains the juzusvr binary and model files. The image can also include Cubic Server as well to get diarization and transcription results together.\n Contact Cobalt to get a link to the image file in AWS S3. This link will expire in two weeks, so be sure to download the file to your own server.\n Download with the AWS CLI if you have it, or with curl:\nURL=\u0026#34;the url sent by Cobalt\u0026#34; IMAGE_NAME=\u0026#34;name you want to give the file (should end with the same extension as the url, usually bz2)\u0026#34; curl $URL -L -o $IMAGE_NAME Load the docker image\ndocker load \u0026lt; $IMAGE_NAME This will output the name of the image (e.g. juzusvr-demo-en_us-16).\n Start the juzu service\ndocker run -p 2727:2727 -p 8080:8080 --name cobalt-juzu juzusvr-demo-en_us-16 That will start a docker container with juzusvr listening for gRPC commands on port 2727 and http requests on 8080, and will stream the log to stdout. (You can replace --name cobalt-juzu with whatever name you want. That just provides a way to refer back to the currently running container.)\nIf the image provided also includes cubicsvr, then adding the arguments -p CUBICSVR_GRPC_PORT:2728 -p CUBICSVR_HTTP_PORT:8081 to the docker run command above will enable you to access cubicsvr directly via CUBICSVR_GRPC_PORT and CUBICSVR_HTTP_PORT for gRPC and HTTP requests respectively. This is useful when you want to only obtain transcription in \u0026ldquo;true\u0026rdquo; streaming mode and diarization is not required.\n Verify the service is running by calling\ncurl http://localhost:8080/api/version  Contents of the docker image  Base docker image : debian-stretch-slim Additional dependencies  sox a subset of pre-compiled kaldi binaries   Cobalt-specific files  juzusvr - binary for performing Speaker Diarization diarization models - models for extracting and scoring speaker embedding vectors\n If configured to include Cubic:\n cubicsvr - binary for performing Automatic Speech Recognition cubic models - speech recognition models and associated files  "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/using-juzu-sdk/",
	"title": "Using Juzu-SDK",
	"tags": [],
	"description": "",
	"content": "This section discusses the various aspects of using the SDK as a client for currently supported languages. For unsupported languages, please see the Juzu API reference, or contact us to request support for your preferred language.\n Installing the SDK Gives language-specific instructions about how to add the SDK to your project.\n    Setup Connection Describes how to connect to a running Juzu server instance.\n  \n Streaming Diarization Describes how to stream audio for diarization.\n  \n Diarization Configurations Describes the configurable options for diarization requests.\n   \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/protobuf/",
	"title": "Juzu API Reference",
	"tags": [],
	"description": "",
	"content": " The Juzu API is specified as a proto file. This section of the documentation is auto-generated from the spec. It describes the data types and functions defined in the spec. The \u0026ldquo;messages\u0026rdquo; below correspond to the data structures to be used, and the \u0026ldquo;service\u0026rdquo; contains the methods that can be called.\njuzu.proto Service: Juzu Service that implements the Cobalt Juzu Diarization API.\n   Method Name Request Type Response Type Description     Version .google.protobuf.Empty VersionResponse Queries the Version of the Server.   ListModels .google.protobuf.Empty ListModelsResponse Retrieves a list of available diarization models.   StreamingDiarize StreamingDiarizeRequest DiarizationResponse Performs bidirectional streaming to enable on-the-go processing of audio files, as well as the option to receive partial transcripts of audio along with speaker IDs. This method is not truly streaming for diarization yet, as results are received after specific chunks of audio have been sent. This method is only available via GRPC and not via HTTP+JSON. However, a web browser may use websockets to use this service.    Message: DiarizationAudio Audio to be sent to the diarizer.\n   Field Type Label Description     data bytes  \n    Message: DiarizationConfig Configuration for setting up a Diarizer.\n   Field Type Label Description     model_id string  ID of the diarization model to use on the server. Can be obtained by first getting list of models on the server via ListModels().\n   num_speakers uint32  The number of speakers expected in the audio; If the number of speakers is unknown, set to 0.\n   sample_rate uint32  Sampling rate of the audio to process.\n   audio_encoding DiarizationConfig.Encoding  Encoding of audio data sent/streamed through the DiarizationAudio messages. For encodings like WAV/MP3 that have headers, the headers are expected to be sent at the beginning of the stream, not in every DiarizationAudio message.\nIf not specified, the default encoding is RAW_LINEAR16.\nDepending on how they are configured, server instances of this service may not support all the encodings enumerated above. They are always required to accept RAW_LINEAR16. If any other Encoding is specified, and it is not available on the server being used, the recognition request will result in an appropriate error message.\n   cubic_model_id string  Unique identifier of the cubic model to be used for speech recognition. If this value is specified, transcription results from the cubic model with the given ID will also be returned alongside speaker labels. If it omitted or blank, the results will not include transcripts, even if Cubic server was included in the deployed image.\n   enable_raw_transcript bool  Returns unformatted transcript.\n    Message: DiarizationResponse Collection of sequence of diarization results in a portion of audio. Juzu currently requires the full audio to determine which audio segments belong to which speaker.\n   Field Type Label Description     results DiarizationResult repeated \n    Message: DiarizationResult A diarization result corresponding to a portion of audio.\n   Field Type Label Description     segments Segment repeated Diarized segments containing speaker labels, timestamps and transcripts.\n   speaker_labels string repeated Set of labels used to identify speakers in each segment.\n   is_partial bool  If this is set to true, it denotes that the result is an interim partial result, and could change after more audio is processed. If unset, or set to false, it denotes that this is a final result and will not change.\nServers are not required to implement support for returning partial results, and clients should generally not depend on their availability.\n    Message: ListModelsResponse The message sent by the server for the ListModels method.\n   Field Type Label Description     models Model repeated List of models available for use that match the request.\n    Message: Model Description of a Juzu Diarization Model.\n   Field Type Label Description     id string  Unique identifier of the model. This identifier is used to choose the model that should be used for diarization, and is specified in the DiarizationConfig message.\n   name string  Model name. This is a concise name describing the model, and maybe presented to the end-user, for example, to help choose which model to use.\n   attributes ModelAttributes  Model attributes.\n    Message: ModelAttributes Attributes of a Juzu Diarization Model.\n   Field Type Label Description     sample_rate uint32  Audio sample rate supported by the model.\n   segmentation_type string  The type of segmentation (fixed / variable) supported by the model.\n    Message: Segment A diarized segment of audio.\n   Field Type Label Description     speaker_label string  The identity of the speaker for this segment.\n   start_time google.protobuf.Duration  Time offset relative to the beginning of audio received by the diarizer and corresponding to the start of this segment.\n   end_time google.protobuf.Duration  Time offset relative to the beginning of audio received by the diarizer and corresponding to the end of this segment.\n   transcript string  Text representing the transcription of the words that the speaker spoke. Formatting options are set in cubicsvr.\n   words WordInfo repeated Words in the transcript, their timestamps and confidence scores.\n    Message: StreamingDiarizeRequest The top-level message sent by the client for the StreamingDiarize request. Multiple StreamingDiarizeRequest messages are sent. The first message must contain a DiarizationConfig message only, and all subsequent messages must contain DiarizationAudio only. All DiarizationAudio messages must contain non-empty audio. If audio content is empty, the server may interpret it as end of stream and stop accepting any further messages.\n   Field Type Label Description     config DiarizationConfig  \n   audio DiarizationAudio  \n    Message: VersionResponse The message sent by the server for the Version method.\n   Field Type Label Description     juzu string  version of the juzu library handling the recognition.\n   server string  version of the server handling these requests.\n    Message: WordInfo Word-specific information for recognized words.\n   Field Type Label Description     word string  The actual word in the text.\n   confidence double  Confidence estimate between 0 and 1. A higher number represents a higher likelihood that the word was correctly recognized.\n   start_time google.protobuf.Duration  Time offset relative to the beginning of audio received by the recognizer and corresponding to the start of this spoken word.\n   duration google.protobuf.Duration  Duration of the current word in the spoken audio.\n    Enum: DiarizationConfig.Encoding The encoding of the audio data to be sent for recognition.\nFor best results, the audio source should be captured and transmitted using the RAW_LINEAR16 encoding.\n   Name Number Description     RAW_LINEAR16 0 Raw (headerless) Uncompressed 16-bit signed little endian samples (linear PCM), single channel, sampled at the rate expected by the chosen Model.   WAV 1 WAV (data with RIFF headers), with data sampled at a rate equal to or higher than the sample rate expected by the chosen Model.   FLAC 2 FLAC data, sampled at a rate equal to or higher than the sample rate expected by the chosen Model.    Scalar Value Types    .proto Type Notes Go Type Python Type     double  float64 float   float  float32 float   int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int   int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 int/long   uint32 Uses variable-length encoding. uint32 int/long   uint64 Uses variable-length encoding. uint64 int/long   sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int   sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 int/long   fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int   fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 int/long   sfixed32 Always four bytes. int32 int   sfixed64 Always eight bytes. int64 int/long   bool  bool boolean   string A string must always contain UTF-8 encoded or 7-bit ASCII text. string str/unicode   bytes May contain any arbitrary sequence of bytes. []byte str    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/using-juzu-sdk/installation/",
	"title": "Installing the SDK",
	"tags": [],
	"description": "Gives language-specific instructions about how to add the SDK to your project.",
	"content": "Instructions for installing the SDK are language specific.\nC# The C# SDK utilizes the NuGet package manager. The package is called Juzu-SDK, under the owners name of CobaltSpeech.\nNuGet allows 4 different ways to install. Further instructions can be found on the nuget webpage. Installing via the dotnet cli through the command:\ndotnet add package Juzu-SDK"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/using-juzu-sdk/connecting/",
	"title": "Setup Connection",
	"tags": [],
	"description": "Describes how to connect to a running Juzu server instance.",
	"content": "Once you have your Juzu server up and running, let\u0026rsquo;s see how we can use the SDK to connect to it.\nFirst, you need to know the address (host:port) where the server is running. This document will assume the values 127.0.0.1:2727, but be sure to change those to point to your server instance.\nDefault Connection The following code snippet connects to the server and queries its version. It uses our recommended default setup, expecting the server to be listening on a TLS encrypted connection, as the demo server does.\n var serverAddress = \u0026#34;127.0.0.1:2727\u0026#34;; // change this to true if using server without TLS var insecure = false; var client = new Client (serverAddress, insecure); // Get Version of the server var ver = client.Version (); Console.WriteLine (\u0026#34;Juzu: {0} Server: {1}\u0026#34;, ver.Juzu, ver.Server);    \nInsecure Connection It is sometimes required to connect to Juzu server without TLS enabled, such as during debugging.\nPlease note that if the server has TLS enabled, attempting to connect with an insecure client will fail. To connect to an instance of Juzu server without TLS enabled, you can use:\n var insecure = true; var client = new Client (serverAddress, insecure);    \nClient Authentication In our recommended default setup, TLS is enabled in the gRPC setup, and when connecting to the server, clients validate the server\u0026rsquo;s SSL certificate to make sure they are talking to the right party. This is similar to how \u0026ldquo;https\u0026rdquo; connections work in web browsers.\nIn some setups, it may be desired that the server should also validate clients connecting to it and only respond to the ones it can verify. If your Juzu server is configured to do client authentication, you will need to present the appropriate certificate and key when connecting to it.\nPlease note that in the client-authentication mode, the client will still also verify the server\u0026rsquo;s certificate, and therefore this setup uses mutually authenticated TLS. This can be done with:\n Authenticating Server Certificate var rootPem = File.ReadAllText(\u0026#34;root.pem\u0026#34;); var client = new Client (serverAddress, rootPem);  Mutual Authentication var rootPem = File.ReadAllText(\u0026#34;root.pem\u0026#34;); var certPem = File.ReadAllText(\u0026#34;cert.pem\u0026#34;); var keyPem = File.ReadAllText(\u0026#34;key.pem\u0026#34;); var client = new Client (serverAddress, rootPem, certPem, keyPem);    \nwhere rootPem is the bytes of the certificate used to validate the server certificate and certPem \u0026amp; keyPem are the bytes of the client certificate and key provided to you respectively.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/using-juzu-sdk/streaming/",
	"title": "Streaming Diarization",
	"tags": [],
	"description": "Describes how to stream audio for diarization.",
	"content": "The following example shows how to diarize and transcribe an audio file using Juzu’s Streaming Diarize Request. The stream can come from a file on disk or be directly from a microphone in real time. The diarization (and transcription) results are returned after the stream is ended and all the audio has been sent to the server.\nFor real-time streaming transcription without diarization, call cubicsvr directly. (See StreamingRecognize in the Cubic SDK documentation.)\nStreaming from an audio file We support several file formats including RAW, WAV and FLAC. For more details, please see the protocol buffer specification file in the SDK repository (grpc/juzu.proto). The examples below use a WAV file as input to the streaming diarization (and transcription).\n Program.cs using System; using System.IO; using System.Net; using System.Text; using System.Threading.Tasks; namespace JuzusvrClient { class Program { static async Task Main (string[] args) { var url = \u0026#34;127.0.0.1:2727\u0026#34;; string audioFile = \u0026#34;test.wav\u0026#34;; var insecure = true; var client = new Client (url, insecure); // Getting list of diarization models on the server  var modelResp = client.ListModels (); Console.WriteLine (\u0026#34;\\nAvailable models:\\n\u0026#34;); foreach (var model in modelResp.Models) { Console.WriteLine (\u0026#34;{0}\\t{1}\\t{2}\\n\u0026#34;, model.Id, model.Name, model.Attributes.SampleRate); } // Creating config for Diarizing + Transcribing file with the first  // Juzu Model available and the Cubic model with ID \u0026#34;1\u0026#34; (assigned by  // cubicsvr config).  var diarCfg = new DiarizationConfig { JuzuModelID = modelList.Models[0].Id, CubicModelID = \u0026#34;1\u0026#34;, NumSpeakers = 2, // use 0 if unknown  SampleRate = 16000, Encoding = AudioEncoding.WAV, }; // Define callback function to print results on screen; could be  // modified to do other things with the results as well.  ResponseHandler handleFunc = delegate (CobaltSpeech.Juzu.DiarizationResponse resp) { foreach (var result in resp.Results) { foreach (var seg in result.Segments) { Console.WriteLine (\u0026#34;{0} : {1}\\t{2}\\t{3}\u0026#34;, seg.StartTime, seg.EndTime, seg.SpeakerLabel, seg.Transcript); } } }; // StreamingDiarizeAsync takes any readable Stream.IO object, that is  // only the Stream.IO.Read method needs to be implemented.  using (FileStream file = File.OpenRead (audioFile)) { await client.StreamingDiarizeAsync (file, diarCfg, handleFunc); } } } }  JuzusvrClient.csproj \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp3.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Juzu-SDK\u0026#34; Version=\u0026#34;0.9.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;    \nStreaming from microphone Streaming audio from microphone input typically needs us to interact with system libraries. There are several options available, and although the examples here use one, you may choose to use an alternative as long as the recording audio format is chosen correctly.\n We do not currently have example C# code for streaming from a microphone. Simply pass the bytes from the microphone the same as is done from the file in the Streaming from an audio file example above via a class derived from Stream.IO. with the int Read(buffer byte[], offset int, count int) method implemented.\n  \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/using-juzu-sdk/client-configs/",
	"title": "Diarization Configurations",
	"tags": [],
	"description": "Describes the configurable options for diarization requests.",
	"content": " An in-depth explanation of the various fields of the complete SDK can be found here. The sub-section DiarizationConfig details the options that can be set when sending a diarization request.\nThis page here discusses the more common combinations sent to the server.\nFields    Field Required Default Description     model_id Yes  ID of the diarization model to use on the server. Can be obtained by first getting list of models on the server via ListModels().\n   num_speakers Yes  The number of speakers expected in the audio; specifying the correct number of speakers improves the accuracy of the speaker labels. If the number of speakers is unknown, set to 0.    audio_encoding Yes  Encoding of audio data sent/streamed through the DiarizationAudio messages. For encodings like WAV/FLAC that have headers, the headers are expected to be sent at the beginning of the stream, not in every DiarizationAudio message.\n   sample_rate Yes  Sampling rate of the audio to process.\n   cubic_model_id Yes if transcription required \u0026rdquo;\u0026rdquo; Unique identifier of the cubic model to be used for speech recognition. If this value is specified, transcription results from the cubic model with the given ID will also be returned alongside speaker labels. If it omitted or blank, the results will not include transcripts, even if Cubic server was included in the deployed image.\n   enable_raw_transcript No False If true, the raw transcript (unformatted) will be included in the results (only has an effect if Cubicsvr also set up with Juzusvr).\n    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Juzu SDK \u0026ndash; Cobalt\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/",
	"title": "Juzu SDK Documentation",
	"tags": [],
	"description": "",
	"content": " Juzu API Overview Juzu is Cobalt\u0026rsquo;s speaker diarization engine. It can be deployed on-prem and accessed over the network or on your local machine via an API. We currently support C# and are adding support for more languages.\nOnce running, Juzu\u0026rsquo;s API provides a method to which you can stream audio. This audio can either be from a microphone or a file. We recommend uncompressed WAV or lossless compression such as FLAC as the encoding, but we can support other formats as well upon request.\nJuzu\u0026rsquo;s API returns the diarization results using Google\u0026rsquo;s protobuf library, allowing them to be handled natively by your application. Juzu returns timestamps for each speaker segment along with the speaker labels. Juzu can also return speaker transcripts (via Cubic) and word-level timestamps. Juzu\u0026rsquo;s output format is described further below.\nDiarization Results Juzu uses protocol buffers to return its results. The fields within these results are listed in the Juzu Protobuf API Docs. Depending on the programming language, the field names may vary in casing.\n Click here to see an example json representation of Juzu\u0026rsquo;s output along with transcription and word level timestamps\n{ \u0026#34;speaker_labels\u0026#34;: [ \u0026#34;S-0\u0026#34;, \u0026#34;S-1\u0026#34; ], \u0026#34;segments\u0026#34;: [ { \u0026#34;speaker_label\u0026#34;: \u0026#34;S-0\u0026#34;, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 1, \u0026#34;nanos\u0026#34;: 740000000 }, \u0026#34;end_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 5, \u0026#34;nanos\u0026#34;: 120000000 }, \u0026#34;transcript\u0026#34;: \u0026#34;My name is Michael. What can I help you with today\u0026#34;, \u0026#34;words\u0026#34;: [ { \u0026#34;word\u0026#34;: \u0026#34;My\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 2, \u0026#34;nanos\u0026#34;: 880000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 150000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 30000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 210000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;is\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 240000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 90000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;Michael.\u0026#34;, \u0026#34;confidence\u0026#34;: 0.99, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 330000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 300000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;What\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 690000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 150000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;can\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 840000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 150000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;confidence\u0026#34;: 0.997, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 3, \u0026#34;nanos\u0026#34;: 990000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 60000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;help\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 4, \u0026#34;nanos\u0026#34;: 50000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 150000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;you\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 4, \u0026#34;nanos\u0026#34;: 200000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 90000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;with\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 4, \u0026#34;nanos\u0026#34;: 290000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 120000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;today\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 4, \u0026#34;nanos\u0026#34;: 410000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 270000000 } } ] }, { \u0026#34;speaker_label\u0026#34;: \u0026#34;S-1\u0026#34;, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 5, \u0026#34;nanos\u0026#34;: 120000000 }, \u0026#34;end_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 7, \u0026#34;nanos\u0026#34;: 410000000 }, \u0026#34;transcript\u0026#34;: \u0026#34;Hi I need to upgrade my service.\u0026#34;, \u0026#34;words\u0026#34;: [ { \u0026#34;word\u0026#34;: \u0026#34;Hi\u0026#34;, \u0026#34;confidence\u0026#34;: 0.689, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 5, \u0026#34;nanos\u0026#34;: 316000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 159000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 5, \u0026#34;nanos\u0026#34;: 679000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 141000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;need\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 5, \u0026#34;nanos\u0026#34;: 820000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 180000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;to\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 6 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 240000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;upgrade\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 6, \u0026#34;nanos\u0026#34;: 240000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 448000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;my\u0026#34;, \u0026#34;confidence\u0026#34;: 0.887, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 6, \u0026#34;nanos\u0026#34;: 768000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 137000000 } }, { \u0026#34;word\u0026#34;: \u0026#34;service.\u0026#34;, \u0026#34;confidence\u0026#34;: 1, \u0026#34;start_time\u0026#34;: { \u0026#34;seconds\u0026#34;: 6, \u0026#34;nanos\u0026#34;: 933000000 }, \u0026#34;duration\u0026#34;: { \u0026#34;nanos\u0026#34;: 477000000 } } ] } ] } \nJuzu can handle both short and long audio streams. The diarization process is initiated with the start of the stream and the results are returned within a few seconds of the stream ending.\nObtaining Juzu Cobalt will provide you with a package of Juzu that contains the engine, appropriate diarization models and a server application. The package may include Cubic as well for transcription and aiding the diarization process. This server exports Juzu\u0026rsquo;s functionality over the gRPC protocol. The https://github.com/cobaltspeech/sdk-juzu repository contains the SDK that you can use in your application to communicate with the Juzu server. This SDK is currently available for C# and we would be happy to talk to you if you need support for other languages. Most of the core SDK is generated automatically using the gRPC tools, and Cobalt provides a top level package for more convenient API calls.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-juzu/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]